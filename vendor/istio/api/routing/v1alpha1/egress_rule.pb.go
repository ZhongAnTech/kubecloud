// Code generated by protoc-gen-go. DO NOT EDIT.
// source: routing/v1alpha1/egress_rule.proto

package istio_routing_v1alpha1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Egress rules describe the properties of a service outside Istio. When transparent proxying
// is used, egress rules signify a white listed set of domains that microserves in the mesh
// are allowed to access. A subset of routing rules and all destination policies can be applied
// on the service targeted by an egress rule. The destination of an egress rule is allowed to
// contain wildcards (e.g., *.foo.com). Currently, only HTTP-based services can be expressed
// through the egress rule. If TLS origination from the sidecar is desired, the protocol
// associated with the service port must be marked as HTTPS, and the service is expected to
// be accessed over HTTP (e.g., http://gmail.com:443). The sidecar will automatically upgrade
// the connection to TLS when initiating a connection with the external service.
//
// For example, the following egress rule describes the set of services hosted under the *.foo.com domain
//
//     kind: EgressRule
//     metadata:
//       name: foo-egress-rule
//     spec:
//       destination:
//         service: *.foo.com
//       ports:
//         - port: 80
//           protocol: http
//         - port: 443
//           protocol: https
//
type EgressRule struct {
	// REQUIRED: Hostname or a wildcard domain name associated with the external service.
	// ONLY the "service" field of destination will be taken into consideration. Name,
	// namespace, domain and labels are ignored. Routing rules and destination policies that
	// refer to these external services must have identical specification for the destination
	// as the corresponding egress rule. Wildcard domain specifications must conform to format
	// allowed by Envoy's Virtual Host specification, such as “*.foo.com” or “*-bar.foo.com”.
	// The character '*' in a domain specification indicates a non-empty string. Hence, a wildcard
	// domain of form “*-bar.foo.com” will match “baz-bar.foo.com” but not “-bar.foo.com”.
	Destination *IstioService `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	// REQUIRED: list of ports on which the external service is available.
	Ports []*EgressRule_Port `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	// Forward all the external traffic through a dedicated egress proxy. It is used in some scenarios
	// where there is a requirement that all the external traffic goes through special dedicated nodes/pods.
	// These dedicated egress nodes could then be more closely monitored for security vulnerabilities.
	//
	// The default is false, i.e. the sidecar forwards external traffic directly to the external service.
	UseEgressProxy bool `protobuf:"varint,3,opt,name=use_egress_proxy,json=useEgressProxy" json:"use_egress_proxy,omitempty"`
}

func (m *EgressRule) Reset()                    { *m = EgressRule{} }
func (m *EgressRule) String() string            { return proto.CompactTextString(m) }
func (*EgressRule) ProtoMessage()               {}
func (*EgressRule) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *EgressRule) GetDestination() *IstioService {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *EgressRule) GetPorts() []*EgressRule_Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *EgressRule) GetUseEgressProxy() bool {
	if m != nil {
		return m.UseEgressProxy
	}
	return false
}

// Port describes the properties of a specific TCP port of an external service.
type EgressRule_Port struct {
	// A valid non-negative integer port number.
	Port int32 `protobuf:"varint,1,opt,name=port" json:"port,omitempty"`
	// The protocol to communicate with the external services.
	// MUST BE one of HTTP|HTTPS|GRPC|HTTP2.
	Protocol string `protobuf:"bytes,2,opt,name=protocol" json:"protocol,omitempty"`
}

func (m *EgressRule_Port) Reset()                    { *m = EgressRule_Port{} }
func (m *EgressRule_Port) String() string            { return proto.CompactTextString(m) }
func (*EgressRule_Port) ProtoMessage()               {}
func (*EgressRule_Port) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

func (m *EgressRule_Port) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *EgressRule_Port) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func init() {
	proto.RegisterType((*EgressRule)(nil), "istio.routing.v1alpha1.EgressRule")
	proto.RegisterType((*EgressRule_Port)(nil), "istio.routing.v1alpha1.EgressRule.Port")
}

func init() { proto.RegisterFile("routing/v1alpha1/egress_rule.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 232 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x8f, 0x4f, 0x4b, 0x03, 0x31,
	0x10, 0xc5, 0x49, 0xff, 0x48, 0x9d, 0x05, 0x91, 0x1c, 0x64, 0xd9, 0xd3, 0x5a, 0x04, 0x73, 0x4a,
	0x69, 0x05, 0x6f, 0x1e, 0x15, 0xbc, 0x95, 0xf8, 0x01, 0xca, 0x5a, 0x87, 0x1a, 0x08, 0x3b, 0x61,
	0x92, 0x14, 0xfd, 0xe0, 0xde, 0x25, 0x69, 0xd5, 0x05, 0xf5, 0xf6, 0xf2, 0x78, 0xbf, 0x97, 0x79,
	0x30, 0x67, 0x4a, 0xd1, 0xf6, 0xbb, 0xc5, 0x7e, 0xd9, 0x39, 0xff, 0xda, 0x2d, 0x17, 0xb8, 0x63,
	0x0c, 0x61, 0xc3, 0xc9, 0xa1, 0xf6, 0x4c, 0x91, 0xe4, 0x85, 0x0d, 0xd1, 0x92, 0x3e, 0x26, 0xf5,
	0x57, 0xb2, 0xb9, 0xfc, 0xc5, 0x66, 0x03, 0x07, 0xe8, 0xfc, 0x43, 0x00, 0xdc, 0x97, 0x42, 0x93,
	0x1c, 0xca, 0x07, 0xa8, 0x5e, 0x30, 0x44, 0xdb, 0x77, 0xd1, 0x52, 0x5f, 0x8b, 0x56, 0xa8, 0x6a,
	0x75, 0xa5, 0xff, 0xee, 0xd7, 0x8f, 0xd9, 0x7e, 0x42, 0xde, 0xdb, 0x2d, 0x9a, 0x21, 0x28, 0xef,
	0x60, 0xea, 0x89, 0x63, 0xa8, 0x47, 0xed, 0x58, 0x55, 0xab, 0xeb, 0xff, 0x1a, 0x7e, 0xbe, 0xd6,
	0x6b, 0xe2, 0x68, 0x0e, 0x94, 0x54, 0x70, 0x9e, 0x02, 0x6e, 0x8e, 0x4b, 0x3d, 0xd3, 0xdb, 0x7b,
	0x3d, 0x6e, 0x85, 0x9a, 0x99, 0xb3, 0x14, 0xf0, 0x00, 0xad, 0xb3, 0xdb, 0xdc, 0xc2, 0x24, 0x83,
	0x52, 0xc2, 0x24, 0xa3, 0xe5, 0xe2, 0xa9, 0x29, 0x5a, 0x36, 0x30, 0x2b, 0x23, 0xb7, 0xe4, 0xea,
	0x51, 0x2b, 0xd4, 0xa9, 0xf9, 0x7e, 0x3f, 0x9f, 0x14, 0x75, 0xf3, 0x19, 0x00, 0x00, 0xff, 0xff,
	0xf5, 0x04, 0x73, 0xab, 0x5f, 0x01, 0x00, 0x00,
}
